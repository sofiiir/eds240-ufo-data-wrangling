---
title: "HW #1"
subtitle: "Interpreting `{ggplot2}` code"
description: "Assigned Wed 01/07/2026 | Due Wed 01/14/2026"
author: "Sofia Rodas"
toc: true
code-line-numbers: true
editor_options: 
  chunk_output_type: console
---

::: {.callout-tip}
## Some notes before you get started
- **Be sure to install any packages** in the Setup chunk that you don't already have.
- **Leave the code chunk options, `eval: false` and `echo: true`, set as they are.** The final infographic has been intentionally optimized (e.g., text size, spacing) for saving and viewing as a PNG file, not for display in the Plots pane or within a rendered Quarto document. As a result, the text in each individual ggplot may appear too large when viewed in the Plots pane, but will be correctly sized in the exported PNG. We’ll talk more about the nuances of saving ggplots (and why these differences occur) in a later lab section.
- Some answers may become clearer once you’ve looked ahead at the code further down in the script. **Consider revisiting questions as you go.**
:::

## I. Setup

```{r}
#| eval: false
#| echo: true

# load in necessary libraries
library(colorspace)
library(geofacet) 
library(ggtext) 
library(glue) 
library(grid)
library(magick)
library(patchwork) 
library(scales) 
library(showtext) 
library(tidyverse) 

# read in the data
ufo_sightings <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2023/2023-06-20/ufo_sightings.csv')
places <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2023/2023-06-20/places.csv')

# assign the colors to variable names
alien <- c("#101319", "#28ee85")
bg <- alien[1]
accent <- alien[2]

# read in the ufo image 
ufo_image <- magick::image_read(path = here::here("images", "ufo.png")) 

# load in fonts from google
sysfonts::font_add_google(name = "Orbitron", family = "orb")
sysfonts::font_add_google(name = "Barlow", family = "bar")

# load in fonts from fonts folder
sysfonts::font_add(family = "fa-brands", regular = here::here("fonts", "Font Awesome 6 Brands-Regular-400.otf"))
sysfonts::font_add(family = "fa-solid", regular = here::here("fonts", "Font Awesome 6 Free-Solid-900.otf"))

# makes applying fonts to graphics easier
showtext::showtext_auto(enable = TRUE)
```

1. **What is the author defining in lines 15-17? Where else in the code do these defined variables show up? What advantage(s) is there to defining these values here, as variables, rather than defining the values directly throughout the script?**

    - The author is defining the colors for the graphic. These colors show up again in the `ggplot` portions of the code. They are the arguments set equal to fill and color. These values are hex codes that are clunky to use over and over again. This would require constantly copying and pasting the hex codes or memorizing them. Since the hex codes appear abritrary to us as humans, it is safer to assign it to a variable that can be easily remembered and called and avoids bugs due to hex code issues.  

2. **In your own words, explain what the function, `font_add_google()`, does. What's the difference between the two arguments, `name` and `family`?**

    - `font_add_google()` references Google fonts and retrieves the specified font. The `name` argument is the specific name for the font in Google Fonts while the `family` refers to the family name in font.

## II. Data wrangling

### i. Create `df_pop`

```{r}
#| eval: false
#| echo: true

# create a df of the states in the us and their respective populations
df_pop <- places |>
  filter(country_code == "US") |>
  mutate(state = str_replace(string = state,  # standardize the state names
                             pattern = "Fl",
                             replacement = "FL")) |> 
  group_by(state) |>
  summarise(pop = sum(population)) |> # add pop for each state together
  ungroup()
```

3. **Describe what this data frame contains.**

    - The `df_pop` data frame contains a list of all of the states in the US and their cooresponding population. Note that there are 51 rows as the District of Columbia is included as a state in this data frame. 

### ii. Create `df_us`

```{r}
#| eval: false
#| echo: true

# create a df for each state in the us, their pop, ufo sightings per 10k and assign an opacity for the ufo sighting
df_us <- ufo_sightings |>
  filter(country_code == "US") |>
  mutate(state = str_replace(string = state,
                             pattern = "Fl",
                             replacement = "FL")) |> 
  count(state) |>
  left_join(df_pop, by = "state") |> # add state pop data 
  rename(num_obs = n) |>  
  mutate(
    num_obs_per10k = num_obs / pop * 10000,
    opacity_val = num_obs_per10k / max(num_obs_per10k)
    )
```

4. **Describe what this data frame contains.**

    - The `df_us` contains a list of all of the states in the US, the number of ufo observations for each state, the population of the state, the number of observations per ten thousand people in the population for each state, and an opacity value calculated based on the number of ufo observations per 10k population. Again the District of Columbia is included accounting for the 51 states.

5. **What does `opacity_val` represent, and why is it calculated?**

    - The opacity values is determined by the states number of observations per ten thousand people in the population for a given state divided by the maximum number of observations per ten thousand people in the population for any state. This opacity value is then used to make the visual depicting the "sightings per 10k population".

### iii. Create `df_shape`

```{r}
#| eval: false
#| echo: true

# create a df showing the top 10 shapes in ufo sightings
df_shape <- ufo_sightings |>
  filter(!shape %in% c("unknown", "other")) |> # select defined shapes
  count(shape) |> # count each shape value
  rename(total_sightings = n) |> 
  arrange(desc(total_sightings)) |> # arrange in descending order
  slice_head(n = 10) |> # select only top 10 sightings 
  mutate(
     shape = fct_reorder(.f = shape, 
                         .x = total_sightings), 
    opacity_val = scales::rescale(x = total_sightings, 
                                  to = c(0.3, 1))
    )
```

6. **Describe what this data frame contains.**

    - The `df_shape` shows the top 10 most common shapes of the UFO sightings. The total sightings for each shape is included as is a calculated opacity value. 

7. **What does `fct_reorder` do when it is applied to the `shape` variable? What would have happened if this step was not performed?**

    - `fct_reorder`orders the data frame in the specified order of `shape`.  If this step were not performed the order would be in alphabetical order. 

8. **What is the purpose of rescaling `opacity_val`? And why rescale from 0.3 to 1?**

    - Creating the `opacity_val` with `rescale` adds a value between 0 and 1. By setting the `rescale` to 0.3 to 1 the opacity values are then changed to 0.3 to 1. An opacity of 0 would have made the value invisible in the visual. 

### iv. Create `df_day_hour`

```{r}
#| eval: false
#| echo: true

df_day_hour <- ufo_sightings |>
  mutate(
    day = wday(reported_date_time), 
    hour = hour(reported_date_time), 
    wday = wday(reported_date_time, label = TRUE) 
  ) |>
  count(day, wday, hour) |>
  rename(total_daily_obs = n) |> 
  mutate(
    opacity_val = total_daily_obs / max(total_daily_obs),
    hour_lab = case_when(
      hour == 0 ~ "12am",
      hour <= 12 ~ paste0(hour, "am"),
      hour == 12 ~ "12pm",
      TRUE ~ paste0(hour - 12, "pm")) 
    )
```

9. **Describe what this data frame contains.**

    - The `df_day_hour` assigns a value from 1 to 7 for the day of the week with Sunday being assigned 1 and Saturday being assigned 7. The `wday` column includes an abbreviation og the weekday. The `hour` column has a numeric value of the hour in the day that the sighting took place. The `total_daily_obs` column is the number of sightings cooresponding with the respective day of the week and time of day. The `opacity_val` assigns an opacity value calculated by dividing the total daily observations and the maximum value of any total daily observation. Lastly, the column `hour_lab` is included as an hour label for the visual. 

10. **What is the purpose of the last line inside the `case_when()` statement (`TRUE ~ paste0(hour - 12, "pm")`)?**

    - The line `TRUE ~ paste0(hour - 12, "pm")` applies to any values that are greater than 12. When the value is greater than 12 the manipulation changes the value from a 24 hour scale to the more commonly used 12 hour time scale. 12 is subtracted from any number greater than 12 and "pm" is added as the label. 

## III. Prepare text elements

```{r}
#| eval: false
#| echo: true

quotes <- paste0('"...', str_to_sentence(ufo_sightings$summary[c(47816, 6795, 93833)]), '..."')

original <- glue("Original visualization by Dan Oehm:")
dan_github <- glue("<span style='font-family:fa-brands;'>&#xf09b;</span> doehm/tidytues")
new <- glue("Updated version by Sam Shanny-Csik for EDS 240:")
link <- glue("<span style='font-family:fa-solid;'>&#xf0c1;</span> eds-240-data-viz.github.io")
space <- glue("<span style='color:{bg};'>. .</span>")
caption <- glue("{original}{space}{dan_github}
                <br><br>
                {new}{space}{link}")
```

11. **In your own words, what is the difference between `paste0()` and `glue()`? Why did the author use `paste0` to construct `quotes` and `glue` to construct the other text elements?**

    - Answer here

## IV. Build plots

### i. Build `plot_shape`

```{r}
#| eval: false
#| echo: true

plot_shape <- ggplot(data = df_shape) +
  geom_col(aes(x = total_sightings, y = shape, alpha = opacity_val), 
           fill = accent) +
  geom_text(aes(x = 200, y = shape, label = str_to_title(shape)), 
            family = "orb", 
            fontface = "bold",
            color = bg, 
            size = 14, 
            hjust = 0,
            nudge_y = 0.2) +
  geom_text(aes(x = total_sightings-200, y = shape, label = scales::comma(total_sightings)),
            family = "orb",
            fontface = "bold",
            color = bg,
            size = 10,
            hjust = 1,
            nudge_y = -0.2) +
  scale_x_continuous(expand = c(0, NA)) +
  labs(subtitle = "10 most commonly reported shapes") +
  theme_void() +
  theme(
    plot.subtitle = element_text(family = "bar", 
                                 size = 40, 
                                 color = accent,
                                 hjust = 0,  
                                 margin = margin(b = 10)),
    legend.position = "none" 
  )
```

12. **Explain the values provided to the `x` aesthetic for both text geoms (`shape` & `total_sightings`).**

    - The `x` value in the aesthetics is specifying the position of the text. 200 is the position given for all of the `shape` titles. The position of the value of the total sightings is determined by the number of total sightings minus 200, towards the end of the column representing the number of sightings. 

### ii. Build `plot_us` 

**HINT:** Consider temporarily commenting out / rearranging the `geom_*()` layers to better understand how this plot is constructed

```{r}
#| eval: false
#| echo: true

plot_us <-  ggplot(df_us) +
  geom_rect(aes(xmin = 0, xmax = 1, ymin = 0, ymax = 1, alpha = opacity_val), 
            fill = accent) +
  geom_text(aes(x = 0.5, y = 0.7, label = state), 
            family = "orb", 
            fontface = "bold",
            size = 9, 
            color = bg) +
  geom_text(aes(x = 0.5, y = 0.3, label = round(num_obs_per10k, 1)), 
            family = "orb", 
            fontface = "bold",
            size = 8, 
            color = bg) +  
  geofacet::facet_geo(~state) +
  coord_fixed(ratio = 1) +
  labs(subtitle = "Sightings per 10k population") +
  theme_void() +
  theme(
    strip.text = element_blank(),
    plot.subtitle = element_text(family = "bar", 
                                 size = 40, 
                                 color = accent,
                                 hjust = 1,  
                                 margin = margin(b = 10)),
    legend.position = "none" 
  )
```

13. **Consider the order of `geom_*()` layers in the the above plot (`plot_us`). Why did the author order the layers in this way?**

    - The `geom_rect()` is the base layer so that the text that follows is visible above. The `geom_text()` has to be on the top in order to be visible. 

### iii. Build `plot_day`

```{r}
#| eval: false
#| echo: true

plot_day <- ggplot(data = df_day_hour) +
  geom_tile(aes(x = hour, y = day, alpha = opacity_val), 
            fill = accent, 
            height = 0.9, 
            width = 0.9) +
  geom_text(aes(x = hour, y = 9, label = hour_lab), 
            family = "orb",
            color = accent, 
            size = 10) +
  geom_text(aes(x = 0, y = day, label = str_sub(string = wday, start = 1, end = 1)), 
            family = "orb", 
            fontface = "bold",
            color = bg, 
            size = 8) + 
  ylim(-5, 9) +
  xlim(NA, 23.55) +
  coord_polar() +
  theme_void() +
  theme(
    plot.background = element_rect(fill = bg, color = bg),
    legend.position = "none"
  )
```

14. **This plot includes one-letter labels for each day of the week. How is this accomplished when week days are written using their three-letter abbreviations (e.g. `Mon`, `Tue`) in the `df_day_hour` data frame?**

    - The code `str_sub(string = wday, start = 1, end = 1)` selects for only the first letter in the weekday. This text is added with `geom_text()` to the visual. 

15. **What role do the `ylim()` and `xlim()` functions play in shaping a ggplot, and how do they change the visual layout of this particular plot? To better understand their effect, try rerunning the code with each of these lines commented out and observe how the plot’s spacing and composition change.**

    - The `ylim()` and `xlim()` define the coordinate values of the graph where the visuals will be spaced. The `ylim()` creates the center circle void of the visual. The `xlim()` creates the spacing between the 11pm and 12am column. 

### iv. Build `quote*`s

A comment from Dan Oehm's original code: "A bit clunky but the path of least resistance."

```{r}
#| eval: false
#| echo: true

quote1 <- ggplot() +
  annotate(geom ="text", 
           x = 0, 
           y = 1, 
           label = str_wrap(string = quotes[1], width = 40),
           family = "bar", 
           fontface = "italic", 
           color = accent, 
           size = 16, 
           hjust = 0, 
           lineheight = 0.4) +
  xlim(0, 1) +
  ylim(0, 1) +
  theme_void() +
  coord_cartesian(clip = "off")

quote2 <- ggplot() +
  annotate(geom = "text", 
           x = 0, 
           y = 1, 
           label = str_wrap(string = quotes[2], width = 25),
           family = "bar", 
           fontface = "italic",
           color = accent, 
           size = 16, 
           hjust = 0,  
           lineheight = 0.4) +
  xlim(0, 1) +
  ylim(0, 1) +
  theme_void() +
  coord_cartesian(clip = "off")

quote3 <- ggplot() +
  annotate(geom = "text", 
           x = 0, 
           y = 1, 
           label = str_wrap(string = quotes[3], width = 25),
           family = "bar", 
           fontface = "italic",
           color = accent, 
           size = 16, 
           hjust = 0,  
           lineheight = 0.4) +
  xlim(0, 1) +
  ylim(0, 1) +
  theme_void() +
  coord_cartesian(clip = "off")
```

16. **Why do you think the author chose to convert these text elements (and also in `plot_ufo`, below!) into ggplot objects (you may consider returning to this question after you've worked your way through all of the code)?**

    - The author likely chose to convert the text into ggplot objects to streamline making the final visual. The different elements all being in the same format makes them work well together. 

### v. Build `plot_ufo`

**Note:** Grob stands for **gr**aphical **ob**ject. Each visual element rendered in a a ggplot (e.g. lines, points, axes, entire panels, even images) is represented as a grob. Grobs can be manipulated individually to fully customize plots. 

```{r}
#| eval: false
#| echo: true
plot_ufo <- ggplot() +
  annotation_custom(grid::rasterGrob(ufo_image)) +
  theme_void() +
  theme(
    plot.background = element_rect(fill = bg, color = bg) 
  )
```

### vi. Build `plot_base` 

```{r}
#| eval: false
#| echo: true

plot_base <- ggplot() +
  labs(
    title = "UFO Sightings",
    subtitle = "Summary of over 88k reported sightings across the US",
    caption = caption
    ) +
  theme_void() +
  theme(
    text = element_text(family = "orb", 
                        size = 48, 
                        lineheight = 0.3, 
                        color = accent),
    plot.background = element_rect(fill = bg, 
                                   color = bg),
    plot.title = element_text(size = 128, 
                              face = "bold", 
                              hjust = 0.5, 
                              margin = margin(b = 10)),
    plot.subtitle = element_text(family = "bar", 
                                 hjust = 0.5, 
                                 margin = margin(b = 20)),
    plot.caption = ggtext::element_markdown(family = "bar",
                                            face = "italic",
                                            color = colorspace::darken(accent, 0.25),
                                            hjust = 0.5,
                                            margin = margin(t = 20)),
    plot.margin = margin(b = 20, t = 50, r = 50, l = 50)
  )
```

17. **Why does the author render `plot.caption` using `ggtext::element_markdown()`, rather than `element_text()` (like he does for rendering `plot.title` and `text`)?**

    - `element_markdown()` is used instead of `element_text()` for the caption as it creates a markdown element and a link can be added to the visual. `element_text()` creates a static visual and does not have the functionality of adding hyperlinks. 

## V. Assemble & save

```{r}
#| eval: false
#| echo: true

plot_final <- plot_base +
  inset_element(plot_shape, left = 0, right = 1, top = 1, bottom = 0.66) +
  inset_element(plot_us, left = 0.42, right = 1, top = 0.74, bottom = 0.33) +
  inset_element(plot_day, left = 0, right = 0.66, top = 0.4, bottom = 0) +
  inset_element(quote1, left = 0.5, right = 1, top = 0.8, bottom = 0.72) +
  inset_element(quote2, left = 0, right = 1, top = 0.52, bottom = 0.4) +
  inset_element(quote3, left = 0.7, right = 1, top = 0.2, bottom = 0) +
  inset_element(plot_ufo, left = 0.25, right = 0.41, top = 0.23, bottom = 0.17) + 
  plot_annotation(
    theme = theme(
      plot.background = element_rect(fill = bg,
                                     color = bg)
    )
  ) 

ggsave(plot = plot_final, 
       filename = here::here("outputs", "ufo_sightings_infographic.png"), 
       height = 16, 
       width = 10)
```

18. **Explain how `plot_final` is assembled. What do you think is the most challenging aspect of arranging all components into a single plot?**

    - `plot_final` is assembled by calling all of the individually created aspect of the final visual and defining the spacing by adding argument values to the `left`, `right`, `top`, and `bottom` parameters. The most challenging aspect of arranging the plots is adequately defining the spacing so that items do not overlap and spacing is aesthetic. 

19. **Can you think of one reason the author may have chosen to separate the construction of `plot_base` and `plot_final`?**

    - Creating the base layer first allows for easier trouble shooting when spacing the plots and quotes. 

## Answer some final reflective questions 

20. **During week 2, we discuss [Choosing the right graphic form](https://eds-240-data-viz.github.io/course-materials/lecture-slides/lecture2.1-choosing-graphic-forms-slides.html#/title-slide). Refer to this lecture when answering the sub-questions, below:**

    a. **What "perceptual tasks" (from Cleveland & McGill's heirarchy) must the viewer perform to extract information from these visualizations?**
        
        - Answer here
    
    b. **What task(s) do you think the author wanted to enable or message(s) he wanted to convey with these visualizations (see lecture 2.1, slide 16 for examples)? Be sure to note at least one task / message for each of the three data viz.**
    
        - Answer here
    
    c. **Name at least one caveat to the "hierarchy of perceptual tasks" that the author employed to achieve a goal(s) you noted in question b?**
    
        - Answer here

21. **Describe two elements of this piece that you find visually-pleasing / easy to understand / intuitive. Why?** 

    - I find the use of opacity visually pleasing and easy to understand. It easily allows me to understand what values are the highest and which values are the lowest without having to read every single value. I also appreciate that the top sightings of UFOs are broken into three different categories: shape, state, and time. This allows us to understand the highest values of UFO sighting in each category. 

22. **Describe two elements of this piece that you feel could be better presented in a different way. Why?** 

    - Though the circular visual representing UFO sighting based on time is visually pleasing it is not super intuitive to understand. Before recreating this visual myself, I did not notice that the day of the week was included. Since the letter is black in a low opacity feature it is difficult to easily make out what it says. This could be improved by even shifting the day of the week indicator to the right where the opacity of the green is much higher. 
    
23. **Describe two new things that you learned by interpreting / annotating this code. These could be packages, functions, or even code organizational approaches that you hadn't previously known about or considered.**

    - Again, I was most impressed by the use of opacity in the visualization. I had never considered defining opacity based on the values of a given variable in the data. I am excited to incorporate this technique into my future work. The code `geofacet::facet_geo(~state)` which arranges the geographic information maintaining some semblence of the geographic orientation is a cool visual package. It adds information to otherwise disjointed visuals.  

24. **How, if at all, did you use AI tools to help you interpret this code? Describe your approach to using these tools for this assignment. In what ways was consulting the documentation more (or less) helpful than using AI?**

    - I did not use AI when interpretting this code. I primarily used the documentation that is available when running `?function` into the console. When the documentation within R studio were not sufficient I explored online resources and occassionally stack overflow and posit. 
